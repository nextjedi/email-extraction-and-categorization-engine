<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Intelligent Message Processor - Architecture Documentation</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
        }
        h1 {
            font-size: 32px;
            font-weight: bold;
            margin-top: 20px;
            margin-bottom: 10px;
            color: #1f1f1f;
        }
        h2 {
            font-size: 24px;
            font-weight: bold;
            margin-top: 18px;
            margin-bottom: 8px;
            color: #1f1f1f;
        }
        h3 {
            font-size: 18px;
            font-weight: bold;
            margin-top: 14px;
            margin-bottom: 6px;
            color: #333;
        }
        h4 {
            font-size: 14px;
            font-weight: bold;
            margin-top: 10px;
            margin-bottom: 4px;
        }
        p {
            margin: 8px 0;
            line-height: 1.6;
        }
        ul, ol {
            margin: 10px 0;
            padding-left: 30px;
        }
        li {
            margin: 4px 0;
            line-height: 1.6;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 10px 0;
            border: 1px solid #ddd;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px 12px;
            text-align: left;
        }
        th {
            background-color: #f5f5f5;
            font-weight: bold;
        }
        code {
            background-color: #f4f4f4;
            padding: 2px 4px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }
        pre {
            background-color: #f4f4f4;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            margin: 10px 0;
        }
        blockquote {
            border-left: 4px solid #ddd;
            padding-left: 15px;
            margin-left: 0;
            color: #666;
        }
        .toc {
            background-color: #f9f9f9;
            padding: 15px;
            border-radius: 4px;
            margin: 15px 0;
        }
        .section {
            page-break-inside: avoid;
            margin-bottom: 20px;
        }
        hr {
            border: none;
            border-top: 2px solid #ddd;
            margin: 20px 0;
        }
    </style>
</head>
<body>

<h1>Intelligent Message Processor - Complete Architecture Documentation</h1>

<blockquote>
<p>All documentation compiled into one Google Docs-ready page</p>
</blockquote>

<hr>

<div class="toc">
<h2>ğŸ“– Table of Contents</h2>
<ol>
<li><a href="#master-index">Master Index</a></li>
<li><a href="#quick-reference">Quick Reference</a></li>
<li><a href="#architecture-decisions">Architecture Decisions</a></li>
<li><a href="#source-services">Source Services Deep Dive</a></li>
<li><a href="#database-strategy">Database Strategy</a></li>
<li><a href="#local-development">Local Development Setup</a></li>
<li><a href="#implementation-blueprint">Implementation Blueprint</a></li>
</ol>
</div>

<hr>

<div class="section" id="master-index">
<h2>ğŸ“š Master Index</h2>

<h3>Where to Start</h3>

<p><strong>First Time Through?</strong></p>
<ol>
<li>Read: Master Index (this section)</li>
<li>Read: Architecture Decisions (understand the "why")</li>
<li>Read: Quick Reference (see your options)</li>
<li>Read: Other docs based on your needs</li>
</ol>

<h3>Document Guide</h3>

<table>
<tr>
<th>Document</th>
<th>Purpose</th>
<th>Time</th>
</tr>
<tr>
<td><strong>Architecture Decisions</strong></td>
<td>8 ADRs explaining why each design decision was made</td>
<td>30 min</td>
</tr>
<tr>
<td><strong>Source Services Deep Dive</strong></td>
<td>How source services work, why they matter, switching libraries</td>
<td>20 min</td>
</tr>
<tr>
<td><strong>Database Strategy</strong></td>
<td>Why PostgreSQL, why Redis, scaling considerations</td>
<td>15 min</td>
</tr>
<tr>
<td><strong>Local Development</strong></td>
<td>How to run everything locally with Docker</td>
<td>20 min</td>
</tr>
<tr>
<td><strong>Implementation Blueprint</strong></td>
<td>Complete monorepo structure, K8s, schemas</td>
<td>45 min</td>
</tr>
<tr>
<td><strong>Quick Reference</strong></td>
<td>Customization guide with 10 scenarios</td>
<td>15 min</td>
</tr>
</table>

<h3>Quick Questions</h3>

<ul>
<li>"Why this design?" â†’ <strong>Architecture Decisions</strong></li>
<li>"How do I run it?" â†’ <strong>Local Development</strong></li>
<li>"How do I add a source?" â†’ <strong>Source Services Deep Dive</strong></li>
<li>"Can I change this?" â†’ <strong>Quick Reference</strong></li>
<li>"Complete picture?" â†’ <strong>Implementation Blueprint</strong></li>
<li>"Database strategy?" â†’ <strong>Database Strategy</strong></li>
</ul>

</div>

<hr>

<div class="section" id="quick-reference">
<h2>âš¡ Quick Reference</h2>

<h3>TL;DR Architecture</h3>

<pre>
Messages Flow
  â†“
[Extraction Service] (via Source Services)
  â†’ raw-messages.extracted (Kafka topic)
  â†“
[Classification Service]
  â†’ classified.[type] (Kafka topics)
  â†“
[Processors] (Job Search, Transaction, Subscription, etc.)
  â†’ Domain-specific results
  â†“
[Dashboard] (Read-only access)
</pre>

<h3>Core Components</h3>

<table>
<tr>
<th>Component</th>
<th>Technology</th>
<th>Why</th>
</tr>
<tr>
<td>Message Extraction</td>
<td>Java/Spring Boot</td>
<td>Type safety, operational maturity</td>
</tr>
<tr>
<td>Classification</td>
<td>Java/Spring Boot + ML</td>
<td>Pattern matching + learning</td>
</tr>
<tr>
<td>Message Queue</td>
<td>Kafka</td>
<td>Event replay, loose coupling</td>
</tr>
<tr>
<td>Storage</td>
<td>PostgreSQL</td>
<td>ACID, relationships, complex queries</td>
</tr>
<tr>
<td>Cache</td>
<td>Redis</td>
<td>Speed, TTL, rate limiting</td>
</tr>
<tr>
<td>Orchestration</td>
<td>Kubernetes</td>
<td>Auto-scaling, self-healing</td>
</tr>
<tr>
<td>Monitoring</td>
<td>Prometheus + Grafana + ELK</td>
<td>Comprehensive observability</td>
</tr>
</table>

<h3>Key Architectural Concepts</h3>

<h4>Source Services Layer</h4>
<ul>
<li>Abstracts away source-specific implementations</li>
<li>Allows swapping libraries without breaking consumers</li>
<li>Example: Switch Telethon â†’ Pyrogram? Only 1 file changes</li>
</ul>

<h4>Three-Tier Pipeline</h4>
<ul>
<li>Extract (fetch from sources)</li>
<li>Classify (tag & categorize)</li>
<li>Process (domain-specific handling)</li>
<li>Each stage independent, can be scaled separately</li>
</ul>

<h4>Event-Driven Architecture</h4>
<ul>
<li>Kafka for loose coupling</li>
<li>Extraction doesn't know about classification</li>
<li>Processors can be added without modifying extraction</li>
<li>Messages can be replayed if processor crashes</li>
</ul>

<h4>Hybrid Storage</h4>
<ul>
<li>PostgreSQL: Durable, relational data</li>
<li>Redis: Fast cache, rate limiting, dedup</li>
</ul>

<h3>Decision Matrix</h3>

<table>
<tr>
<th>Component</th>
<th>Keep If</th>
<th>Reconsider If</th>
</tr>
<tr>
<td>3-tier pipeline</td>
<td>Need modularity</td>
<td>Only 1 source, real-time &lt;100ms</td>
</tr>
<tr>
<td>Event-driven</td>
<td>Multiple consumers</td>
<td>Simple monolith sufficient</td>
</tr>
<tr>
<td>Per-source schemas</td>
<td>Flexibility needed</td>
<td>All sources identical structure</td>
</tr>
<tr>
<td>PostgreSQL</td>
<td>Relational data</td>
<td>&gt;100M msgs/day or unstructured</td>
</tr>
<tr>
<td>Microservices</td>
<td>Team &gt;3 people</td>
<td>Single developer, single server</td>
</tr>
</table>

</div>

<hr>

<div class="section" id="architecture-decisions">
<h2>ğŸ—ï¸ Architecture Decisions</h2>

<h3>Overview</h3>

<p>8 Architectural Decision Records (ADRs) explaining the "why" behind every major choice.</p>

<h3>ADR-1: Three-Tier Pipeline Architecture</h3>

<p><strong>Decision:</strong> Implement Extract â†’ Classify â†’ Process pipeline</p>

<p><strong>Rationale:</strong></p>
<ul>
<li>Separation of concerns: Each stage has single responsibility</li>
<li>Parallelization: Classification doesn't wait for extraction</li>
<li>Reusability: Classification can run independently</li>
<li>Monitoring: Clear measurement points</li>
</ul>

<p><strong>Alternative:</strong> Monolithic processing</p>
<ul>
<li>Would require knowing all sources/processors upfront</li>
<li>Restart entire system to add new processor</li>
<li>Single point of failure</li>
</ul>

<p><strong>Trade-off:</strong> Slightly more complex infrastructure, but gains flexibility</p>

<h3>ADR-2: Source Services as Independent Layer</h3>

<p><strong>Decision:</strong> Create dedicated services that abstract away source implementations</p>

<p><strong>Rationale:</strong></p>
<ul>
<li>Library isolation: Swap Telethon â†’ Pyrogram without touching extraction</li>
<li>Reusability: Multiple consumers (extraction, processors, dashboard) use same source</li>
<li>Testability: Mock sources without complex setup</li>
<li>Future modularity: Each source becomes independent microservice</li>
</ul>

<p><strong>Architecture:</strong></p>
<pre>
SourceMessagesApi (Interface)
    â†“
GmailMessagesService (Orchestration)
    â†“
GmailApiClient (Library wrapper)
    â†“
com.google.api.services.gmail (Google library)
</pre>

<h3>ADR-3: Strategy Pattern for Extractors & Classifiers</h3>

<p><strong>Decision:</strong> Pluggable extraction and classification strategies</p>

<p><strong>Rationale:</strong></p>
<ul>
<li>Runtime selection: Choose strategy based on source/classifier type</li>
<li>Easy testing: Swap implementations for mocking</li>
<li>Future improvements: A/B test classifiers</li>
</ul>

<h3>ADR-4: Event-Driven via Kafka</h3>

<p><strong>Decision:</strong> Use Kafka as primary communication bus</p>

<p><strong>Rationale:</strong></p>
<ul>
<li>Decoupling: Extraction doesn't know about classification</li>
<li>Scalability: Multiple consumers process same event</li>
<li>Replay: If processor crashes, reprocess from Kafka</li>
<li>Audit trail: Every decision captured</li>
</ul>

<p><strong>Topic Structure:</strong></p>
<pre>
raw-messages.extracted (produced by Extraction)
    â†“
classified.transactional
classified.job-search
classified.subscription
classified.personal
classified.travel
classified.other
</pre>

<h3>ADR-5: Per-Source Database Schemas</h3>

<p><strong>Decision:</strong> Create separate DB schemas for each source</p>

<p><strong>Rationale:</strong></p>
<ul>
<li>Schema fit: Gmail has threads/labels; WhatsApp has chats; SMS has none</li>
<li>Query optimization: Each schema optimized for its patterns</li>
<li>Independent evolution: Update one without touching others</li>
<li>Operational clarity: Easy to see field purposes</li>
</ul>

<h3>ADR-6: Hybrid SQL + Redis Caching</h3>

<p><strong>Decision:</strong> PostgreSQL for durability, Redis for performance</p>

<p><strong>Rationale:</strong></p>
<ul>
<li>Deduplication cache (Redis): Check before DB query</li>
<li>Contact cache (Redis): User's email contacts</li>
<li>Classification cache (Redis): Recent decisions</li>
<li>Rate limiting (Redis): Track attempts</li>
<li>Session store (Redis): JWT tokens</li>
</ul>

<p><strong>Cache Invalidation:</strong></p>
<ul>
<li>Contact Cache: TTL 24 hours</li>
<li>Classification Cache: TTL 7 days</li>
<li>Dedup Cache: TTL 30 days</li>
<li>Rate Limit: TTL 1 hour</li>
</ul>

<h3>ADR-7: Microservices with Kubernetes</h3>

<p><strong>Decision:</strong> Deploy each service as independent K8s pod</p>

<p><strong>Rationale:</strong></p>
<ul>
<li>Horizontal scaling: Scale extraction independently from classification</li>
<li>Fault isolation: One crash doesn't take down others</li>
<li>Resource control: Classification gets more CPU; extraction gets more I/O</li>
<li>Deployment velocity: Deploy v2 without touching v1</li>
</ul>

<h3>ADR-8: Polyglot (Java + Python)</h3>

<p><strong>Decision:</strong> Core services in Java, specialized services (Telegram) in Python</p>

<p><strong>Rationale:</strong></p>
<ul>
<li>Java: Strong types, Spring ecosystem, operational maturity</li>
<li>Python: Telegram (Telethon) best in Python; ML easier</li>
<li>Container approach: Each service in Docker; language doesn't matter</li>
</ul>

</div>

<hr>

<div class="section" id="source-services">
<h2>ğŸ”Œ Source Services Deep Dive</h2>

<h3>What is a Source Service?</h3>

<p>A dedicated microservice handling all interactions with one message source (Gmail, WhatsApp, Telegram, SMS).</p>

<h3>Three-Layer Architecture</h3>

<p><strong>Layer 1: Interface (SourceMessagesApi)</strong></p>
<ul>
<li>Defines contract all sources implement</li>
<li>Examples: fetchMessages(), sendMessage(), getMessageDetails()</li>
<li>Belongs in: shared module</li>
<li>Benefit: Consumers code against interface, not implementation</li>
</ul>

<p><strong>Layer 2: Service Implementation (GmailMessagesService)</strong></p>
<ul>
<li>Orchestrates client calls</li>
<li>Handles retries, caching, error handling</li>
<li>Maps library-specific objects to domain models</li>
<li>Belongs in: each source service</li>
<li>Benefit: Stable if library changes</li>
</ul>

<p><strong>Layer 3: Client (GmailApiClient)</strong></p>
<ul>
<li>Encapsulates ALL library-specific code</li>
<li>Only place importing Google API, Telethon, Whatsapp4j</li>
<li>Belongs in: each source service</li>
<li>Benefit: Easy to find and replace library usage</li>
</ul>

<h3>Switching Libraries: The Power</h3>

<p><strong>Example: Switch Gmail from Google API to Bazel's client</strong></p>

<p><strong>Changes needed:</strong></p>
<pre>
Only file that changes:
  gmail-service/GmailApiClient.java
  
Changes are:
  1. Remove: import com.google.api.services.gmail
  2. Add: import com.bazel.gmail
  3. Update: Method implementations
  
No changes to:
  4. GmailMessagesService âœ“
  5. SourceMessagesApi âœ“
  6. extraction-service âœ“
  7. processors âœ“
  8. dashboard âœ“
</pre>

<p><strong>Risk & Time Reduction:</strong> 80% less risky, 75% less time</p>

<h3>Design Patterns</h3>

<ul>
<li><strong>Factory Pattern:</strong> SourceServiceFactory.getService(SourceType.GMAIL) â†’ GmailMessagesService</li>
<li><strong>Adapter Pattern:</strong> Gmail Library API â†’ GmailApiClient â†’ SourceMessagesApi</li>
<li><strong>Facade Pattern:</strong> GmailMessagesService hides complex client interactions</li>
</ul>

</div>

<hr>

<div class="section" id="database-strategy">
<h2>ğŸ’¾ Database Strategy</h2>

<h3>Why PostgreSQL (Not MongoDB)</h3>

<p><strong>Message Data is Relational:</strong></p>
<pre>
Message
  â”œâ”€ Attachments (1:N)
  â”œâ”€ Contacts (1:N)
  â””â”€ Classification (1:1)
    â”œâ”€ Extracted Contacts (1:N)
    â””â”€ Confidence Scores (1:1, JSON)
</pre>

<p><strong>MongoDB would require:</strong></p>
<ul>
<li>Manual joins in code</li>
<li>No referential integrity</li>
<li>Ad-hoc validation</li>
</ul>

<p><strong>PostgreSQL provides:</strong></p>
<ul>
<li>Foreign keys (data integrity)</li>
<li>Transactions (atomic deduplication)</li>
<li>Rich queries</li>
</ul>

<p><strong>Data Volume:</strong></p>
<ul>
<li>10k users Ã— 20 messages/day = 200k messages/day</li>
<li>7.3M messages/year</li>
<li>PostgreSQL handles easily</li>
</ul>

<h3>Why Redis for Caching</h3>

<p><strong>Speed:</strong></p>
<pre>
Redis (memory): O(1) = 1ms
PostgreSQL (disk): Index query = 10ms
For 20k msgs/day: 20s vs 200s
</pre>

<p><strong>Capabilities:</strong></p>
<ul>
<li>TTL support (auto-expiry)</li>
<li>Atomic operations (rate limiting)</li>
<li>Multiple data types</li>
</ul>

<h3>Per-Source Schemas</h3>

<p><strong>Why separate tables per source:</strong></p>
<ul>
<li>Gmail: thread_id, labels (not in SMS)</li>
<li>WhatsApp: chat_id, is_group (not in Email)</li>
<li>Each optimized for its patterns</li>
<li>Independent evolution</li>
</ul>

<h3>Scaling Considerations</h3>

<p><strong>Current:</strong> 10k users, 2x/day, ~20k msgs/day</p>
<ul>
<li>Storage: 100MB/day = 36GB/year</li>
<li>PostgreSQL single replica handles easily</li>
</ul>

<p><strong>Future (1M users):</strong> 20M msgs/day</p>
<ul>
<li>Partition by user_id (sharding)</li>
<li>Archive old messages to cold storage</li>
<li>Still PostgreSQL, just distributed</li>
</ul>

<p><strong>If 100M msgs/day:</strong> Consider Cassandra or TimeScale</p>

</div>

<hr>

<div class="section" id="local-development">
<h2>ğŸ³ Local Development Setup</h2>

<h3>Quick Start</h3>

<pre>
# 1. Clone
git clone https://github.com/tvashtar/intelligent-message-processor.git

# 2. Start stack
cd infrastructure/docker-compose
docker-compose -f docker-compose.dev.yml up -d

# 3. Check status
docker-compose -f docker-compose.dev.yml ps

# 4. Access services
open http://localhost:3000  # Grafana
open http://localhost:8082  # Kafka UI
open http://localhost:8888  # Adminer (DB UI)
</pre>

<h3>Services & Ports</h3>

<table>
<tr>
<th>Service</th>
<th>Port</th>
<th>URL</th>
</tr>
<tr>
<td>Extraction Service</td>
<td>8080</td>
<td>http://localhost:8080</td>
</tr>
<tr>
<td>Classification Service</td>
<td>8081</td>
<td>http://localhost:8081</td>
</tr>
<tr>
<td>Grafana</td>
<td>3000</td>
<td>http://localhost:3000</td>
</tr>
<tr>
<td>Prometheus</td>
<td>9090</td>
<td>http://localhost:9090</td>
</tr>
<tr>
<td>Kafka UI</td>
<td>8082</td>
<td>http://localhost:8082</td>
</tr>
<tr>
<td>Kibana</td>
<td>5601</td>
<td>http://localhost:5601</td>
</tr>
</table>

<h3>Database Credentials</h3>

<table>
<tr>
<th>Service</th>
<th>User</th>
<th>Password</th>
</tr>
<tr>
<td>Extraction DB</td>
<td>imp_user</td>
<td>dev_password_extraction</td>
</tr>
<tr>
<td>Classification DB</td>
<td>imp_user</td>
<td>dev_password_classification</td>
</tr>
<tr>
<td>Processors DB</td>
<td>imp_user</td>
<td>dev_password_processors</td>
</tr>
</table>

<h3>Common Commands</h3>

<pre>
# Start all services
docker-compose -f docker-compose.dev.yml up -d

# Stop all
docker-compose -f docker-compose.dev.yml down

# View logs
docker-compose -f docker-compose.dev.yml logs -f extraction-service

# Shell into container
docker-compose -f docker-compose.dev.yml exec extraction-service /bin/bash

# Database access
docker-compose -f docker-compose.dev.yml exec postgres-extraction \
  psql -U imp_user -d imp_extraction

# Reset everything
docker-compose -f docker-compose.dev.yml down -v
docker-compose -f docker-compose.dev.yml up -d
</pre>

</div>

<hr>

<div class="section" id="implementation-blueprint">
<h2>ğŸ“ Implementation Blueprint</h2>

<h3>Monorepo Structure</h3>

<pre>
intelligent-message-processor/
â”‚
â”œâ”€â”€ shared/
â”‚   â””â”€â”€ src/main/java/com/tvashtar/imp/
â”‚       â”œâ”€â”€ common/
â”‚       â”‚   â”œâ”€â”€ dto/
â”‚       â”‚   â”œâ”€â”€ event/
â”‚       â”‚   â””â”€â”€ constant/
â”‚       â””â”€â”€ strategy/
â”‚           â”œâ”€â”€ ExtractionStrategy.java (interface)
â”‚           â””â”€â”€ ClassificationStrategy.java (interface)
â”‚
â”œâ”€â”€ source-services/
â”‚   â”œâ”€â”€ gmail-service/
â”‚   â”‚   â”œâ”€â”€ api/
â”‚   â”‚   â”‚   â””â”€â”€ GmailMessagesApi.java (interface)
â”‚   â”‚   â”œâ”€â”€ service/
â”‚   â”‚   â”‚   â””â”€â”€ GmailMessagesService.java (implements interface)
â”‚   â”‚   â””â”€â”€ client/
â”‚   â”‚       â””â”€â”€ GmailApiClient.java (wraps Google API)
â”‚   â”œâ”€â”€ whatsapp-service/
â”‚   â”œâ”€â”€ telegram-service/ (Python)
â”‚   â””â”€â”€ sms-service/
â”‚
â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ extraction-service/
â”‚   â”‚   â”œâ”€â”€ strategy/
â”‚   â”‚   â”‚   â”œâ”€â”€ GmailExtractionStrategy.java
â”‚   â”‚   â”‚   â”œâ”€â”€ WhatsAppExtractionStrategy.java
â”‚   â”‚   â”‚   â””â”€â”€ TelegramExtractionStrategy.java
â”‚   â”‚   â””â”€â”€ repository/
â”‚   â”‚       â”œâ”€â”€ GmailMessageRepository.java
â”‚   â”‚       â””â”€â”€ WhatsAppMessageRepository.java
â”‚   â”‚
â”‚   â”œâ”€â”€ classification-service/
â”‚   â”‚   â”œâ”€â”€ strategy/
â”‚   â”‚   â”‚   â”œâ”€â”€ RuleBasedClassifier.java
â”‚   â”‚   â”‚   â”œâ”€â”€ MLClassifier.java
â”‚   â”‚   â”‚   â””â”€â”€ HybridClassifier.java
â”‚   â”‚   â””â”€â”€ repository/
â”‚   â”‚       â””â”€â”€ ClassificationRepository.java
â”‚   â”‚
â”‚   â”œâ”€â”€ job-search-processor/
â”‚   â”œâ”€â”€ transaction-processor/
â”‚   â””â”€â”€ subscription-processor/
â”‚
â”œâ”€â”€ infrastructure/
â”‚   â”œâ”€â”€ kubernetes/
â”‚   â”‚   â”œâ”€â”€ extraction-service/
â”‚   â”‚   â”œâ”€â”€ classification-service/
â”‚   â”‚   â”œâ”€â”€ processors/
â”‚   â”‚   â”œâ”€â”€ kafka/
â”‚   â”‚   â”œâ”€â”€ postgres/
â”‚   â”‚   â””â”€â”€ monitoring/
â”‚   â”‚
â”‚   â””â”€â”€ docker-compose/
â”‚       â”œâ”€â”€ docker-compose.dev.yml
â”‚       â””â”€â”€ init-scripts/
â”‚
â”œâ”€â”€ docs/
â”‚   â”œâ”€â”€ ARCHITECTURE_DECISIONS.md
â”‚   â”œâ”€â”€ SOURCE_SERVICES_DEEP_DIVE.md
â”‚   â”œâ”€â”€ DB_CHOICE_RATIONALE.md
â”‚   â””â”€â”€ LOCAL_DEVELOPMENT_DOCKER.md
â”‚
â””â”€â”€ pom.xml (root)
</pre>

<h3>Key Interfaces</h3>

<p><strong>SourceMessagesApi (shared module):</strong></p>
<pre>
public interface SourceMessagesApi {
    List<SourceMessage> fetchMessages(String userId, 
        LocalDateTime from, LocalDateTime to);
    IncrementalFetchResult fetchIncremental(String userId, 
        String syncToken);
    String sendMessage(String userId, SendMessageRequest request);
    SourceType getSourceType();
}
</pre>

<p><strong>ExtractionStrategy (shared module):</strong></p>
<pre>
public interface ExtractionStrategy {
    ExtractionResult extract(ExtractionRequest request);
    SourceType getSourceType();
}
</pre>

<p><strong>ClassificationStrategy (shared module):</strong></p>
<pre>
public interface ClassificationStrategy {
    ClassificationResult classify(RawMessageDTO message);
    String getStrategyName();
}
</pre>

<h3>Kafka Topics</h3>

<pre>
raw-messages.extracted 
    â†“ (consumed by Classification Service)
classified.transactional
classified.job-search
classified.subscription
classified.personal
classified.travel
classified.other
    â†“ (consumed by specific processors)
[Processors store results in their DBs]
</pre>

</div>

<hr>

<div class="section">
<h2>âœ… Summary & Next Steps</h2>

<h3>What This Documentation Covers</h3>

<ul>
<li>âœ… <strong>Architecture</strong> - 8 ADRs explaining every major design decision</li>
<li>âœ… <strong>Source Services</strong> - How to abstract sources and switch libraries</li>
<li>âœ… <strong>Databases</strong> - Why PostgreSQL + Redis, scaling strategy</li>
<li>âœ… <strong>Local Development</strong> - Docker-compose setup to run everything</li>
<li>âœ… <strong>Implementation</strong> - Complete monorepo structure, K8s manifests</li>
<li>âœ… <strong>Quick Reference</strong> - Decision matrix and 10 customization scenarios</li>
</ul>

<h3>Next Steps</h3>

<ol>
<li><strong>Understand:</strong> Read architecture decisions</li>
<li><strong>Build:</strong> Use implementation blueprint</li>
<li><strong>Run:</strong> Follow local development guide</li>
<li><strong>Extend:</strong> Use source services pattern to add new sources</li>
<li><strong>Deploy:</strong> Use Kubernetes manifests for production</li>
</ol>

<h3>Questions?</h3>

<p>Refer to the section most relevant to your needs:</p>
<ul>
<li>Why this decision? â†’ Architecture Decisions</li>
<li>How to run it? â†’ Local Development</li>
<li>How to add source? â†’ Source Services Deep Dive</li>
<li>Can I change this? â†’ Quick Reference</li>
<li>Database strategy? â†’ Database Strategy</li>
</ul>

</div>

</body>
</html>
